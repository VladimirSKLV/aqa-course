# Урок 1. Переменные и типы данных (Java)

## Зачем это AQA

В автотестах вы постоянно:

- храните **данные ответов API** (id, статус, суммы, даты),
- работаете с **таймаутами и ожиданиями** (миллисекунды, секунды),
- сравниваете **ожидаемое и фактическое** (строки, числа, коллекции),
- обрабатываете **отсутствие данных** (нет поля, элемент не найден).

Ошибки выбора типов приводят к:

- неверным сравнениям (`5 / 2` даёт `2`, а не `2.5`),
- переполнениям (неожиданные отрицательные значения у `int`),
- «плавающим» ошибкам точности (`double` для денег),
- `NullPointerException` при обращении к отсутствующим данным.

Этот урок — база: после него вы будете уверенно выбирать тип под реальные задачи AQA.

---

## 1) Переменная: что это и зачем

**Переменная** — именованная область памяти, в которой хранится значение **конкретного типа**.

Пример из автотестов: вы получили `userId` из ответа API, сохранили, а затем используете его в следующем запросе.

```java
int userId = 123;
```

Важное правило: **тип определяет**, какие значения допустимы и какие операции корректны.

---

## 2) Примитивные типы: что важно знать

Java делит типы на:

- **примитивы** (значение хранится «как есть»): `int`, `long`, `double`, `float`, `boolean`, `char` и др.
- **ссылочные типы** (в переменной хранится ссылка на объект): `String`, любые классы, массивы.

### 2.1) `int` и `long`: целые числа

| Тип | Размер | Диапазон | Типичные случаи в AQA |
|---|---:|---:|---|
| `int` | 32 бита | примерно ±2.1 млрд | HTTP status code, счётчики, небольшие id |
| `long` | 64 бита | очень большой | большие id, timestamp (epochMillis), длительности, размеры файлов |

**Когда выбирать `int`:**

- вы точно знаете, что значение не выйдет за пределы ~2.1 млрд;
- это небольшие счётчики, статусы, индексы.

**Когда выбирать `long`:**

- id в «больших» системах (часто 64‑битные),
- `System.currentTimeMillis()` возвращает `long` (epoch millis),
- измерения времени/таймауты в миллисекундах,
- любые значения, где «в теории может вырасти».

**Переполнение (overflow)** — классическая причина «странных» автотестов:

```java
int x = Integer.MAX_VALUE;
int y = x + 1;
System.out.println(y); // станет отрицательным
```

В реальной работе это всплывает, когда:

- вы храните timestamp в `int`;
- приводите id из JSON к `int`, а он уже превышает диапазон;
- суммируете значения и не контролируете тип результата.

### 2.2) `double` и `float`: числа с плавающей точкой

| Тип | Размер | Точность | Когда применим |
|---|---:|---:|---|
| `float` | 32 бита | ниже | почти не нужен в AQA |
| `double` | 64 бита | выше | метрики, проценты, расчёты, где допустима погрешность |

**Главное:** `double/float` не подходят для точного хранения десятичных дробей.

Пример:

```java
double a = 0.1 + 0.2;
System.out.println(a); // 0.30000000000000004
```

**Практика AQA:**

- для денег и точных сумм используйте `BigDecimal`;
- для `double`‑значений сравнивайте с допуском (epsilon), если бизнес‑логика допускает погрешность.

### 2.3) `boolean`

`boolean` — флаг `true/false`.

В тестах это:

- `isActive`, `enabled`, `deleted`, `hasAccess`;
- проверки «элемент отображается/нет».

```java
boolean isActive = response.isActive();
org.junit.jupiter.api.Assertions.assertTrue(isActive);
```

### 2.4) `char`

`char` — одиночный символ (16‑битный Unicode).

В AQA используется редко напрямую, чаще вы работаете со строками.

---

## 3) Деление и приоритет типов

Очень частая ошибка: целочисленное деление.

```java
int a = 5 / 2;      // 2
double b = 5 / 2;   // 2.0 (сначала int/int)
double c = 5 / 2.0; // 2.5
```

**Правило:** если оба операнда целые — результат целый.

В автотестах это критично при проверках процентов, коэффициентов, средних значений.

---

## 4) Ссылочные типы: `String` и объекты

### 4.1) `String` — основной тип в тестах

`String` — объект (ссылочный тип). В AQA вы постоянно храните строки:

- URL, токены,
- значения полей JSON,
- текст в UI,
- локаторы/селекторы,
- сообщения ошибок.

```java
String token = "Bearer abc";
String expectedTitle = "Dashboard";
```

### 4.2) Почему `String` immutable (неизменяемая)

`String` нельзя «изменить» — любая операция создаёт новый объект.

```java
String s = "A";
s = s + "B"; // создаётся новый String
```

Это полезно, потому что:

- строки безопасно использовать между потоками;
- строки можно кэшировать/интернировать;
- строки безопасны как ключи в `Map`.

**Практика AQA:** при сборке больших строк (логи, отчёты) используйте `StringBuilder`, чтобы не плодить объекты:

```java
StringBuilder sb = new StringBuilder();
sb.append("userId=").append(userId);
String logLine = sb.toString();
```

### 4.3) Сравнение строк

Строки сравнивают **по содержимому** через `equals`, а не через `==`.

```java
String a = new String("ok");
String b = new String("ok");

System.out.println(a == b);      // false (разные объекты)
System.out.println(a.equals(b)); // true
```

В тестах это особенно важно при assertions.

---

## 5) `null`: отсутствие значения и источник падений

`null` означает “значения нет”. Это не пустая строка и не ноль.

```java
String name = null;
System.out.println(name.length()); // NullPointerException
```

Типичные источники `null` в AQA:

- поле отсутствует в JSON;
- элемент не найден на странице;
- объект не инициализирован в тесте.

**Практика:**

- проверяйте, что данные пришли (`assertNotNull`),
- используйте безопасные проверки,
- изолируйте парсинг/маппинг данных.

---

## 6) Деньги и точные значения: `BigDecimal`

Если вы действительно сравниваете суммы (а не просто проверяете “поле существует”), используйте `BigDecimal`.

```java
import java.math.BigDecimal;

BigDecimal expected = new BigDecimal("10.50");
BigDecimal actual = new BigDecimal("10.5");

// compareTo сравнивает по значению (0 = равно)
org.junit.jupiter.api.Assertions.assertEquals(0, expected.compareTo(actual));
```

---

## Мини‑чеклист выбора типа для AQA

- HTTP status code, маленькие числа → `int`
- id может быть большим, epochMillis, длительности → `long`
- флаги (активен/нет) → `boolean`
- метрики/проценты с допуском → `double`
- деньги/точные десятичные значения → `BigDecimal`
- текст/поля JSON/локаторы → `String`

Дальше в курсе эти типы будут постоянно встречаться в assertions JUnit и при работе с RestAssured/UI.
