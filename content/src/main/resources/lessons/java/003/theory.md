# Урок 003 (Beginner): Условия, циклы и методы — управляем логикой автотестов

В автотестах почти всё сводится к **управлению логикой**:

- если ответ API *успешный* — проверяем тело ответа, иначе — логируем и падаем;
- если элемент *появился* — кликаем, иначе — делаем скриншот и завершаем тест;
- если в списке *есть нужная запись* — валидируем её поля, иначе — это дефект.

Эта логика реализуется через **условия (`if/switch`)**, **циклы (`for/while`)** и **методы** (переиспользуемые куски кода).

---

## 1) Булева логика и сравнения: что реально важно в AQA

### 1.1 boolean и условия
Условные конструкции работают на выражениях типа `boolean`:

```java
boolean ok = true;
if (ok) {
    System.out.println("Continue");
}
```

В реальной работе `boolean` чаще получается из **сравнений** или **проверок**:

```java
int status = 200;
boolean success = status >= 200 && status < 300;
```

### 1.2 Операторы сравнения
- `==` равно  
- `!=` не равно  
- `>` больше, `<` меньше  
- `>=`, `<=`

Пример из API-тестов:

```java
int status = response.statusCode();
if (status != 200) {
    // Логика обработки ошибки
}
```

### 1.3 Логические операторы: &&, ||, !
- `&&` (AND) — оба условия истинны  
- `||` (OR) — достаточно одного истинного  
- `!` (NOT) — отрицание

Пример: успешные статусы 2xx **или** редирект 3xx (иногда это допустимо):

```java
boolean ok = (status >= 200 && status < 300) || (status >= 300 && status < 400);
```

### 1.4 Очень частая ошибка: сравнение строк через ==
В Java `==` сравнивает **ссылки**, а не содержимое.

❌ Неправильно:
```java
String actual = "OK";
if (actual == "OK") { ... }
```

✅ Правильно:
```java
if ("OK".equals(actual)) { ... }
```

Практика AQA: писать `"CONST".equals(value)` — это безопасно даже если `value == null`.

---

## 2) if / else: ветвление без “спагетти”

### 2.1 Базовый if/else
```java
if (status == 200) {
    // проверяем тело ответа
} else {
    // логируем и падаем
}
```

### 2.2 else-if цепочки
```java
if (status == 200) {
    ...
} else if (status == 404) {
    ...
} else {
    ...
}
```

Реальность AQA: часто удобно разнести обработку “ожидаемых” ошибок и “неожиданных”.

### 2.3 Тернарный оператор (?:)
Тернарник полезен **для присваивания**, но не стоит превращать его в “мини-скриптовый язык”.

```java
String label = status >= 200 && status < 300 ? "OK" : "FAIL";
```

---

## 3) switch: читаемая логика по категориям

### 3.1 switch по int / String
```java
switch (status) {
    case 200 -> System.out.println("OK");
    case 401 -> System.out.println("AUTH ERROR");
    default -> System.out.println("OTHER");
}
```

### 3.2 switch expression (Java 17): возвращаем значение
```java
String group = switch (status / 100) {
    case 2 -> "SUCCESS";
    case 4 -> "CLIENT_ERROR";
    case 5 -> "SERVER_ERROR";
    default -> "OTHER";
};
```

Почему это полезно в тестах:
- можно быстро классифицировать статус/тип ошибки;
- упрощает читаемость там, где `if/else-if` становятся длинными.

---

## 4) Циклы: перебираем данные, элементы UI, записи из API

### 4.1 for (классический): когда нужен индекс
```java
for (int i = 0; i < 10; i++) {
    System.out.println(i);
}
```

В AQA индекс нужен, когда:
- проверяем таблицу/список “по строкам”;
- хотим вывести понятный лог `"row #5 failed"`.

### 4.2 enhanced for (for-each): когда индекс не нужен
```java
int[] codes = {200, 404, 500};
for (int code : codes) {
    System.out.println(code);
}
```

В тестах это чаще всего:
- пройтись по списку сущностей из API;
- пройтись по найденным web-элементам.

### 4.3 while / do-while: осторожно, это “оружие”
`while` удобен, когда условие неизвестно заранее.

Пример “ожидания” (НЕ лучший, но показательный):

```java
int tries = 0;
while (tries < 10 && !elementAppeared()) {
    sleep(200);
    tries++;
}
```

Важно:
- в UI-тестах лучше использовать ожидания фреймворка (Selenide/Selenium wait),
- иначе получите flaky-тесты (нестабильные).

### 4.4 break / continue
- `break` — выйти из цикла
- `continue` — пропустить итерацию

Пример: ищем первую запись по условию:
```java
for (String name : names) {
    if (name == null) continue;
    if (name.startsWith("QA-")) {
        System.out.println("Found: " + name);
        break;
    }
}
```

---

## 5) Методы: главный инструмент переиспользования в тестах

В тестах очень быстро появляется дублирование:

- “проверить, что status 2xx”
- “проверить, что поле не null”
- “распечатать ошибку красиво”
- “получить токен авторизации”

Правильный подход: выносить повторяющееся в методы.

### 5.1 Сигнатура метода
```java
static boolean is2xx(int status) {
    return status >= 200 && status < 300;
}
```

### 5.2 Возврат значения vs void
- `void` — метод делает действие (логирование/клик/сохранение)
- не-void — метод вычисляет и возвращает результат

### 5.3 Параметры: передаём то, что меняется
Плохо (магические числа внутри):
```java
static boolean isOk() { return status == 200; }
```

Хорошо:
```java
static boolean isOk(int status) { return status == 200; }
```

### 5.4 Перегрузка (overloading)
```java
static void assertStatus(int status) { ... }
static void assertStatus(int status, String msg) { ... }
```

В тестах это удобно: можно давать “короткий” вариант и “расширенный”.

---

## 6) Пример из реальной AQA-логики

### 6.1 API: проверяем список сущностей
Пример кода проверки статуса кода от HTTP:

```java
List<Integer> statuses = List.of(200, 201, 404);

for (int s : statuses) {
    if (is2xx(s)) {
        // валидируем JSON
    } else {
        // логируем body и падаем
    }
}
```

### 6.2 UI: проверяем, что все кнопки активны
Идея:
- получили список элементов
- перебрали
- если нашли disabled — фиксируем дефект

---

## Домашнее задание (Урок 003)

### Часть A — тест (в приложении)
В тесте будут вопросы про:
- `==` vs `equals` для String
- логические операторы `&&` / `||`
- `switch` и группы статусов
- циклы и off-by-one ошибки
- зачем выносить логику в методы

### Часть B — код (в приложении)
Нужно дописать метод `is2xx(int code)` и получить ожидаемый вывод.

Ключевая цель: научиться писать **маленькие проверочные методы**, которые затем переиспользуются в автотестах.

