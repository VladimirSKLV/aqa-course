# Advanced 3. Коллекции, Stream API и Optional

## Цель урока

Научиться писать компактные и надёжные проверки для массивов/списков из API: фильтровать, агрегировать, группировать и безопасно извлекать данные.

## 1) Коллекции: выбираем структуру под задачу

```java
List<Integer> codes = List.of(200, 201, 404); // Нужен порядок и возможные дубликаты.
Set<String> ids = Set.of("u1", "u2");       // Нужна уникальность.
Map<String, Integer> counts = Map.of("ok", 2, "fail", 1); // Нужна связь ключ-значение.
```

## 2) Stream-пайплайн

```java
long okCount = codes.stream()                   // Открываем поток по коллекции кодов.
        .filter(c -> c >= 200 && c < 300)       // Оставляем только успешные ответы.
        .count();                                // Считаем количество элементов после фильтрации.
```

## 3) Optional как безопасный результат поиска

```java
Optional<Integer> firstFail = codes.stream()    // Ищем первый проблемный код.
        .filter(c -> c < 200 || c >= 300)
        .findFirst();

int failValue = firstFail.orElse(-1);           // Если не нашли, возвращаем техническое значение по умолчанию.
```

## 4) Пример агрегации суммы

```java
BigDecimal total = orders.stream()                          // Проходим по заказам.
        .filter(o -> o.status() == Status.PAID)            // Берём только оплаченные.
        .map(Order::amount)                                // Извлекаем поле amount.
        .reduce(BigDecimal.ZERO, BigDecimal::add);         // Складываем суммы без потери точности.
```

## Домашнее задание

Смешанное:
- часть A: тестирование по коллекциям/Stream/Optional,
- часть B: написание кода с подсчётом суммы, сбором уникальных тегов и поиском первого FAILED.
