# Advanced 3. Коллекции, Stream API и Optional

## Почему это критично для AQA

При тестировании API/UI вы почти всегда получаете **коллекции объектов**:
- список заказов,
- набор тегов,
- историю событий,
- результаты фильтрации.

Задача инженера AQA — быстро и надёжно проверить эти данные: отфильтровать, сгруппировать, посчитать агрегаты, найти проблемные элементы.

---

## Определения

- **Коллекция** — контейнер объектов (`List`, `Set`, `Map`).
- **Stream** — конвейер операций над данными (фильтрация, преобразование, агрегация).
- **Terminal operation** — финальная операция стрима (`collect`, `count`, `reduce`, `findFirst`).
- **Optional** — контейнер «значение может отсутствовать».
- **Агрегация** — вычисление итогового значения по набору (сумма, максимум, группировка).

---

## 1) Выбор коллекции под задачу

### `List`
Сохраняет порядок и допускает дубликаты.

Подходит, когда важно:
- проверить точный порядок элементов;
- пройтись по всем ответам как они пришли.

### `Set`
Хранит уникальные значения.

Подходит, когда важно:
- убедиться, что теги/ID не повторяются;
- сравнить множества без учёта порядка.

### `Map`
Пары ключ-значение.

Подходит для:
- индексации по `id`;
- группировок и подсчётов.

---

## 2) Stream API в тестовых проверках

```java
BigDecimal paidTotal = orders.stream()
        .filter(o -> "PAID".equals(o.status()))
        .map(Order::amount)
        .reduce(BigDecimal.ZERO, BigDecimal::add);
```

Базовый pipeline:
1. `filter` — оставили нужные элементы.
2. `map` — взяли нужное поле.
3. `reduce/collect` — получили результат.

### Важный момент: порядок

`HashSet/HashMap` не гарантируют порядок обхода.
Если проверка зависит от порядка, сортируйте:

```java
List<String> sorted = tags.stream()
        .sorted()
        .toList();
```

---

## 3) Optional без `null`-ловушек

`findFirst()` возвращает `Optional<T>`:

```java
Optional<Order> failed = orders.stream()
        .filter(o -> "FAILED".equals(o.status()))
        .findFirst();
```

Безопасные варианты:
- `orElse(defaultValue)`
- `orElseThrow(() -> new AssertionError("..."))`
- `ifPresent(...)`

Плохая практика в тестах:
- `optional.get()` без проверки.

---

## 4) Группировка и отчётность

```java
Map<String, Long> byStatus = orders.stream()
        .collect(java.util.stream.Collectors.groupingBy(
                Order::status,
                java.util.stream.Collectors.counting()
        ));
```

Так можно проверять распределение:
- сколько `PAID`,
- сколько `FAILED`,
- нет ли неожиданных статусов.

---

## 5) Практические правила устойчивых тестов

1. Для денег — `BigDecimal`, не `double`.
2. Для сравнений наборов — сортировка или `Set`-подход.
3. Для отсутствующих элементов — `Optional` + явная ошибка через `orElseThrow`.
4. Не смешивайте проверку бизнес-правила и подготовку данных в одну длинную цепочку — выделяйте методы.

Так код тестов остаётся читаемым, предсказуемым и удобным для расширения.
