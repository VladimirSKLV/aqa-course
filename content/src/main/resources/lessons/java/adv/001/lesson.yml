id: "java-adv-001"
language: "JAVA"
track: "ADVANCED"
order: 1
title: "Точность чисел, даты и парсинг данных в автотестах"
theory:
  markdown: "lessons/java/adv/001/theory.md"
assignment:
  type: "quiz"
  passPercent: 80
  questions:
    - text: "Почему в автотестах нельзя надёжно сравнивать денежные суммы как double == double?"
      options:
        - text: "Из-за ошибок округления в IEEE-754; для денег лучше BigDecimal или сравнение с допуском"
          correct: true
          explanation: "double хранит число в двоичном формате и создаёт накопленные ошибки. Для денег в проверках используйте BigDecimal (или сравнение по округлённому значению/epsilon — если бизнес допускает)."
        - text: "Потому что double всегда хранит только 2 знака после запятой"
          correct: false
          explanation: "Количество знаков после запятой не фиксировано. Проблема в двоичном представлении и округлении."
        - text: "Потому что double нельзя сериализовать в JSON"
          correct: false
          explanation: "double отлично сериализуется. Проблема не в JSON, а в точности."
    - text: "Какая практика наиболее надёжна при сравнении дат/времени из API в тестах?"
      options:
        - text: "Парсить в java.time (Instant/OffsetDateTime) и сравнивать с учётом часового пояса и допуска"
          correct: true
          explanation: "Строковое сравнение легко ломается из‑за формата, TZ, миллисекунд. Парсинг в java.time + явный timezone и допуск (если время 'примерное') делают тест стабильнее."
        - text: "Сравнивать только первые 10 символов строки"
          correct: false
          explanation: "Это частный хак, который легко ломается при изменении формата и не проверяет смысл значения."
        - text: "Всегда приводить к локальному времени машины"
          correct: false
          explanation: "Локальное время машины зависит от окружения CI. В тестах лучше использовать явные зоны (UTC) и контролируемые преобразования."
    - text: "Зачем в AQA полезно уметь задавать допуск (epsilon) при сравнении вещественных чисел?"
      options:
        - text: "Чтобы тесты не падали из‑за микропогрешностей округления при вычислениях/конвертациях"
          correct: true
          explanation: "Вычисления, конвертации валют, проценты, агрегаты могут давать разницу на 1e-9. С допуском вы проверяете бизнес‑смысл, а не артефакты IEEE-754."
        - text: "Чтобы скрывать любые баги в расчётах"
          correct: false
          explanation: "Epsilon должен быть обоснован бизнес‑требованиями (например, округление до 2 знаков). Слишком большой допуск действительно замаскирует дефект."
        - text: "Потому что BigDecimal не поддерживает сравнение"
          correct: false
          explanation: "BigDecimal сравнивается нормально (compareTo/equals с учётом scale). Epsilon нужен именно для float/double."
    - text: "Что часто является причиной flaky-тестов при проверке времени ответа/таймингов?"
      options:
        - text: "Зависимость от реального времени и нестабильности окружения; нужны допуски и изоляция"
          correct: true
          explanation: "Сеть, нагрузка, CI, GC влияют на тайминги. Проверки должны быть устойчивыми: порог, ретраи, мок времени/таймера, профилирование."
        - text: "Потому что System.currentTimeMillis() всегда возвращает случайное значение"
          correct: false
          explanation: "Значение не случайное, но зависимо от времени и может дрейфовать/быть неточным для измерений."
        - text: "Потому что long нельзя использовать для времени"
          correct: false
          explanation: "long как раз стандартен для epochMillis. Проблема в логике проверки и допусках, а не в типе."
