# Продвинутый урок 1. Точность чисел, даты и парсинг данных в автотестах (Java)

## Зачем это AQA

На продвинутом уровне вы будете часто ловить **flaky‑поведение** и **ложные падения** из‑за:

- неточной арифметики (`double`, `float`),
- сравнения дат/времени строками,
- некорректного учёта временных зон,
- проверок таймингов без допусков.

Правильный подход здесь — это не “написать проверку”, а **сделать проверку стабильной и осмысленной для бизнеса**.

---

## 1) IEEE‑754 и почему `double` “ломает” сравнения

`double` и `float` хранят числа в двоичном виде. Многие десятичные дроби (например, 0.1) нельзя представить точно.

Пример:

```java
double a = 0.1 + 0.2;
System.out.println(a); // 0.30000000000000004
```

### Как проверять значения в тестах

1) Если это “денежное” значение (цена, сумма, комиссия) — используйте `BigDecimal`:

```java
import java.math.BigDecimal;

BigDecimal expected = new BigDecimal("0.30");
BigDecimal actual = new BigDecimal("0.1").add(new BigDecimal("0.2"));

// compareTo: 0 если равны по значению
org.junit.jupiter.api.Assertions.assertEquals(0, expected.compareTo(actual));
```

2) Если это расчёт/метрика, где допустима погрешность — сравнивайте с допуском (epsilon):

```java
double expected = 12.5;
double actual = getMetric();
double eps = 1e-6;

org.junit.jupiter.api.Assertions.assertTrue(Math.abs(expected - actual) < eps);
```

**Важно:** допуск должен быть обоснован (округление, требования бизнеса). “Большой eps, чтобы не падало” — прямой путь скрыть дефекты.

---

## 2) Даты и время: не сравнивайте строками

Сравнение строк удобно, но нестабильно:

- формат может поменяться (`Z`, миллисекунды, offset),
- разные таймзоны,
- локаль/настройки окружения.

Правильнее:

1) Парсить время в типы `java.time`.
2) Сравнивать по смыслу (`Instant` в UTC, `OffsetDateTime` с явным offset).
3) Если значение “примерное” — задавать допуск.

Пример (ISO‑8601 из API):

```java
import java.time.Instant;

Instant createdAt = Instant.parse("2026-02-13T10:15:30Z");
Instant now = Instant.now();

// пример: createdAt должен быть не в будущем
org.junit.jupiter.api.Assertions.assertTrue(!createdAt.isAfter(now));
```

Если время может отличаться в пределах нескольких секунд:

```java
import java.time.Duration;
import java.time.Instant;

Instant expected = ...;
Instant actual = ...;

Duration diff = Duration.between(expected, actual).abs();
org.junit.jupiter.api.Assertions.assertTrue(diff.compareTo(Duration.ofSeconds(2)) <= 0);
```

---

## 3) Тайминги и flaky‑тесты

Проверки “операция должна выполниться за 100ms” часто нестабильны:

- CI медленнее локальной машины,
- сеть и внешние сервисы дают дрейф,
- GC/нагрузка влияют на задержки.

Практика AQA:

- измерения производительности — в отдельные профили/перф‑тесты,
- в функциональных тестах — более широкие пороги или проверка SLA как отдельный отчёт,
- мок/изоляция времени (где возможно),
- ретраи/ожидания в UI‑тестах с разумными таймаутами.

---

## Итог

На продвинутом уровне ваша задача — делать проверки устойчивыми:

- `BigDecimal` для денег,
- epsilon для float/double, когда допустимо,
- `java.time` вместо строк,
- допуски и контроль окружения для времени и таймингов.
